% User guide for the Eigen Compiler Suite
% Copyright (C) Florian Negele

% This file is part of the Eigen Compiler Suite.

% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.3
% or any later version published by the Free Software Foundation.

% You should have received a copy of the GNU Free Documentation License
% along with the ECS.  If not, see <https://www.gnu.org/licenses/>.

\input{utilities}
\renewcommand{\seeguide}{}

\startchapter{Getting Started}{User Guide}{guide}
{This \documentation{} provides a basic guide for novice users of the \ecs{}.
It explains how to get started with the toolchain and shows some typical use cases.
In the end, users will understand the functionality of the \ecs{} by building executable programs.}

\epigraph{Man f\"uhlt den Glanz von einer neuen Seite, \\ auf der noch alles werden kann.}{Rainer Maria Rilke}

\section{Introduction}

The \ecs{} features a set of development tools for several programming languages targeting a variety of hardware architectures.
This \documentation{} demonstrates how to use these tools in order to build executable applications.
The assumption is that the user already knows how to program in the programming languages presented in this \documentation{}.
For each programming language supported by the \ecs{} there are the following tools for processing and translating the source code:

\begin{itemize}
\item Pretty printers for reformatting the source code
\item Semantic checkers for analyzing the source code for semantic errors
\item Interpreters for executing the source code line by line
\item Compilers for translating the source code into executable machine code
\end{itemize}

All of these tools have the same functionality regardless of which programming language they actually implement.
Without loss of generality, the remainder of this guide therefore focuses exemplarily on the Oberon programming language.
\seeoberon
Regarding the hardware architectures on the other hand, the \ecs{} provides the following tools for each supported hardware architecture:

\begin{itemize}
\item Assemblers for translating assembly code into binary machine code
\item Disassemblers for translating machine code into human-readable text
\end{itemize}

The \ecs{} provides a couple of assemblers, all of which implement the same generic assembly language.
\seeassembly
In general, users can target any hardware architecture supported by the \ecs{} by just replacing the corresponding tools and their runtime support.
For instructional purposes, the remainder of this \documentation{} therefore assumes that the user targets the AMD64 hardware architecture.
\seeamd
Finally, for building executable programs generated by compilers and assemblers the \ecs{} provides the following tools:

\begin{itemize}
\item Linkers for combining binary data into an executable file
\item Debugging tools for processing debugging information
\end{itemize}

The debugging information generated by compilers and linkers allows debugging problematic programs and consists of a symbolic address mapping.
\seedebugging

\section{Prerequisites}

In order to process and build the examples shown in this guide, the user needs access to the following tools:

\begin{itemize}
\item \tool{obprint} for pretty printing Oberon modules
\item \tool{obcheck} for analyzing Oberon modules
\item \tool{obrun} for interpreting Oberon modules
\item \tool{obamd64} for compiling Oberon modules
\item \tool{amd64asm} for translating assembly code
\item \tool{amd64dism} for translating the generated machine code
\item \tool{linklib} for combining object files
\item \tool{linkbin} for linking an executable program
\item \tool{mapsearch} for debugging programs
\item \tool{dbgdwarf} for converting debugging information
\end{itemize}

The examples shown in Sections~\ref{sec:guidebasic} to~\ref{sec:guidedebugging} assume that all of these tools are executable from the current working directory.
The illustrated commands to invoke these tools may therefore have to be adjusted to their actual location and may additionally require a suffix for executable files.
Furthermore, all executable programs created using the compiler require runtime support which is provided by the following object and library files:

\begin{itemize}
\item \file{obamd64run.lib} required by the programming language
\item \file{amd64run.obf} required by the hardware architecture
\item \file{win64run.obf}, \file{osx64run.obf}, or \file{amd64linuxrun.obf} required by runtime environments like Windows, OS~X, or Linux-based operating systems
\end{itemize}

These files are assumed to be located in the current working directory as well and may therefore also have to be adjusted accordingly.
They store binary data such as the machine code of precompiled runtime support for the respective hardware architecture and runtime environment.
\seeobject

Installations of the \ecs{} typically feature a driver utility tool called \tool{ecsd} which is able to automatically locate and invoke all of the tools discussed in this section.
It also provides the necessary runtime support without requiring users to explicitly name any of the prerequisites listed above.
See Section~\ref{sec:guidedriver} for more information about how to run the examples described in Sections~\ref{sec:guidebasic} to~\ref{sec:guidedebugging} using the \ecs{} driver.
\ifbook For more information about this tool in general, see Chapter~\ref{interface}. \fi

The remainder of this section gives more detailed information about the required tools.
\interface

\renewcommand{\seeoberon}{}
\renewcommand{\seeassembly}{}
\renewcommand{\seeamd}{}
\renewcommand{\seedebugging}{}
\renewcommand{\seeobject}{}

\obprint
\obcheck
\obrun
\obamdc
\amdcasm
\amdcdism
\linklib
\linkbin
\mapsearch
\dbgdwarf

\section{Basic Processing}\label{sec:guidebasic}

The first example is a very simple Oberon module that defines a global variable, assigns a value to it and prints that value.
The corresponding source code looks as follows:

\begin{quote}\begin{verbatim}
MODULE Simple;
VAR variable: INTEGER;
BEGIN
  variable := 10;
  TRACE (variable);
END Simple.
\end{verbatim}\end{quote}

The remainder of this section assumes that these six lines of source code are stored in a plain text file called \file{simple.mod} in the current working directory.

\subsection{Pretty Printing}

Executing the pretty printer should yield the very same code in a slightly different layout and helps to check whether the source was syntactically recognized.
The corresponding command-line call looks like the following and produces the subsequent output:

\begin{quote}\begin{verbatim}
obprint simple.mod
MODULE Simple;

VAR
  variable: INTEGER;

BEGIN
  variable := 10;
  TRACE (variable);
END Simple.
\end{verbatim}\end{quote}

\subsection{Semantic Checking}

For checking whether the source code is also semantically valid one can execute the semantic checker using the following command-line call:

\begin{quote}\begin{verbatim}
obcheck simple.mod
\end{verbatim}\end{quote}

Since the input was semantically valid, the invocation of this tool does not generate any output message and succeeds.
However, if line 5 of the original source code was for example changed to \texttt{TRACE (x);} then the tool would identify a violation of the language rules:

\begin{quote}\begin{verbatim}
obcheck simple.mod
simple.mod:5:10: error: undeclared identifier 'x'
\end{verbatim}\end{quote}

If the semantic checker succeeds, it generates a plain text file called \file{simple.sym} in the current working directory which contains additional semantic information about the source code.
In the case of Oberon, this file is a symbol file containing the interface of the sample module which is required by other modules importing it.

\subsection{Interpreting}

Valid modules can be executed by the interpreter which simulates a runtime environment for the Oberon language.
The corresponding command-line call looks like the following and produces the subsequent output:

\begin{quote}\begin{verbatim}
obrun simple.mod
simple.mod:5:10: note: 'variable' = 10
\end{verbatim}\end{quote}

The interpreter does not generate any output files.
It just executes the source code line by line by first assigning the value 10 to the variable and then printing its value.

\section{Building Simple Programs}\label{sec:guidesimple}

Running code using the interpreter is quite slow compared to executing the same program directly on the machine.
This section shows how the same source code can be translated into an executable program.

\subsection{Compiling}

The compiler translates the source code of the sample module into machine code using the following command-line call:

\begin{quote}\begin{verbatim}
obamd64 simple.mod
\end{verbatim}\end{quote}

If its invocation is successful, the compiler generates four different plain text files for this module.
The first file \file{simple.sym} is the same symbol file as generated by the semantic checker.
The second file \file{simple.obf} is an object file which stores the binary encoding of the machine code translated from the source code.
The third file \file{simple.lst} is a human-readable assembly code listing of the generated machine code.
The fourth file \file{simple.dbg} contains additional symbolic debugging information about the module.
The last two files are actually not required for building the executable program but are generated for debugging purposes.
Invoking the assembler on the assembly code listing using the following command-line call yields exactly the same object file:

\begin{quote}\begin{verbatim}
amd64asm simple.lst
\end{verbatim}\end{quote}

\subsection{Linking}

Although the generated object file contains executable machine code, it is not executable by itself.
The machine code has first to be combined with the required runtime support for the programming language, the hardware architecture, as well as the runtime environment.
This process is called linking and can be executed by invoking the linker using the following command-line call.
The actual order of the command-line arguments is not important but the linker takes the filename of the first object file as a basis for its output files:

\begin{quote}\begin{verbatim}
linkbin simple.obf obamd64run.lib amd64run.obf win64run.obf
\end{verbatim}\end{quote}

If this call succeeds, the linker generates a binary image of an executable program and stores it in a file called \file{simple.exe}.
This file can be executed on a machine running the Windows operating system producing exactly the same output as the interpreter above.
For creating a similar executable file called \file{simple} for the OS~X operating system, only the last command-line argument has to be changed:

\begin{quote}\begin{verbatim}
linkbin simple.obf obamd64run.lib amd64run.obf osx64run.obf
\end{verbatim}\end{quote}

This executable program still needs the same runtime support for the programming language and hardware architecture.
The same holds for programs that can be executed on Linux-based operating systems.
Again only the last command-line argument has to be modified accordingly:

\begin{quote}\begin{verbatim}
linkbin simple.obf obamd64run.lib amd64run.obf amd64linuxrun.obf
\end{verbatim}\end{quote}

In all three cases, the linker also generates a plain text file called \file{simple.map} summarizing the mapping of symbol names in the source code to their linked addresses.
This information is provided for debugging purposes and used in Section~\ref{sec:guidedebugging}.

\section{Building Complex Programs}\label{sec:guidecomplex}

The second example makes use of the interoperability features of the \ecs{}.
It shows how code from one programming language can access code and data defined in another language and vice versa.

\subsection{Compiling}

Here is an extended version of the first example.
Instead of assigning the value to the global variable directly, this version calls a procedure that overwrites the value of the variable.
In the end however, it should generate the same output as the previous example:

\begin{quote}\begin{verbatim}
MODULE Complex;
IMPORT SYSTEM;
VAR variable: INTEGER;
PROCEDURE ^ Assign ["assign"] (value: INTEGER);
BEGIN
  Assign (10);
  TRACE (variable);
END Complex.
\end{verbatim}\end{quote}

The forward declaration of the procedure is marked as external which causes the compiler to refer to the procedure using the given external name instead of defining a new procedure.
If the source code is stored in a plain text file called \file{complex.mod}, the compiler can be invoked using the following command-line call:

\begin{quote}\begin{verbatim}
obamd64 complex.mod
\end{verbatim}\end{quote}

The resulting plain text files are called \file{complex.sym}, \file{complex.obf}, \file{complex.lst}, and \file{complex.dbg}.
However, linking the generated object file together with the runtime support for any runtime environment as before yields the following linker error:

\begin{quote}\begin{verbatim}
linkbin complex.obf obamd64run.lib amd64run.obf amd64linuxrun.obf
Complex._body: error: unresolved symbol 'assign'
\end{verbatim}\end{quote}

The diagnostic message states that the body of the module calls a procedure called \texttt{assign} which is defined nowhere.
This behavior is intended because all external procedures need to be defined by another part of the program.
The following section shows how to implement it using assembly language.

\subsection{Assembling}

The missing \texttt{assign} procedure is defined in the following assembly source code.
It contains instructions which copy the procedure argument into a register and from there into the global variable:

\begin{quote}\begin{verbatim}
.code assign
  mov  ebx, [rsp + 8]
  mov  [@Complex.variable], ebx
  ret
\end{verbatim}\end{quote}

Assuming these four lines of source code are stored in a plain text file called \file{assign.asm}, the assembler can be invoked using the following command-line call:

\begin{quote}\begin{verbatim}
amd64asm assign.asm
\end{verbatim}\end{quote}

This generates an object file called \file{assign.obf} which stores the binary representation of the corresponding machine code of this procedure.
Its contents can be listed by the disassembler using the following command-line call which produces the subsequent output:

\begin{quote}\begin{verbatim}
amd64dism assign.obf
.code assign
   0  8b5c2408        mov  ebx, dword [rsp + 8]
   4  891c2500000000  mov  dword [0], ebx  ; abs @Complex.variable
  11  c3              ret
  12
\end{verbatim}\end{quote}

The disassembler lists all three instructions which require twelve octets of code space in total.
Each instruction is prefixed with its relative offset and binary encoding.

\subsection{Combining}

The following step is optional but shows how the object files generated by the compiler and the assembler can be merged together.
The result is a new object file called a library file which combines the machine code of the Oberon module with the procedure defined in the assembly code.
It is generated using the following command-line call:

\begin{quote}\begin{verbatim}
linklib complex.obf assign.obf
\end{verbatim}\end{quote}

This call generates a new library file called \file{complex.lib} which contains the contents of both object files.
This file can be used to link the executable program in the next step.

\subsection{Linking}

Since the library file contains the machine code of both the module and the \texttt{assign} procedure, the linker should not fail any longer.
The corresponding command-line call looks like the following:

\begin{quote}\begin{verbatim}
linkbin complex.lib obamd64run.lib amd64run.obf amd64linuxrun.obf
\end{verbatim}\end{quote}

This call generates a new binary executable file called \file{complex} that produces the same output as before when executed.
The second generated file \file{complex.map} contains the mapping of symbol names in the source code to their linked addresses and includes the new \texttt{assign} procedure.

The linker could have also been called using the two object files generated by the assembler and the compiler instead of the single library file yielding exactly the same result.
This combining and linking works for arbitrary object files generated by the various development tools of the \ecs{} as long as they target the same hardware architecture.

\section{Debugging Programs}\label{sec:guidedebugging}

Compilers and linkers provided by the \ecs{} generate various files for debugging purposes.
This section shows how this symbolic debugging information can be used to debug problematic programs.

\subsection{Basic Debugging}

If an erroneous program fails, the corresponding error message of the runtime environment or debugger often mentions the address of the first problematic instruction.
The \ecs{} provides a debugging tool called \tool{mapsearch} which allows searching map files generated by linker tools for the section encompassing the reported address.
This is helpful for identifying the executed code section and all other active procedures in a stack trace.
The tool reads a single address from the standard input stream and prints the name of the identified section if it is listed in the specified map file.
For convenience, the address can be provided by a single command-line call as follows:

\begin{quote}\begin{verbatim}
echo 0x80482a7 | mapsearch complex.map
mapsearch: note: offset 4 in code section 'assign'
\end{verbatim}\end{quote}

The address in this particular example corresponds to the instruction at offset four relative to the \texttt{assign} procedure.
If additionally provided with the object file containing the identified section, the tool also generates a separate object file called \file{complex.msr} which can be used to disassemble only that section:

\begin{quote}\begin{verbatim}
echo 0x80482a7 | mapsearch complex.map complex.lib
amd64dism complex.msr
\end{verbatim}\end{quote}

Searching map files generated by linkers for problematic addresses is a rather limited debugging facility but always available.

\subsection{Advanced Debugging}

For runtime environments that support more spohisticated debuggers, the \ecs{} provides tools that convert the symbolic debugging information generated by its compilers alongside an object file into a suitable format.
This debugging information consists of an abstract representation of all programming language constructs compiled into the object file and can be converted as follows for example:

\begin{quote}\begin{verbatim}
dbgdwarf complex.dbg
\end{verbatim}\end{quote}

This generates a debugging object file called \file{complex.dbf} which can optionally be provided together with the corresponding object file when linking for Linux-based operating systems:

\begin{quote}\begin{verbatim}
linkbin complex.obf complex.dbf assign.obf
        obamd64run.lib amd64run.obf amd64linuxrun.obf
\end{verbatim}\end{quote}

The resulting binary executable file behaves as before but additionally contains debugging information that enables interactive program animation and memory inspection when loaded in an external debugger.

\section{Using the \ecs{} Driver}\label{sec:guidedriver}

In addition to invoking tools directly as shown above, users can also call the \tool{ecsd} driver utility tool which is typically provided when installing the \ecs{}.
It allows compiling and linking complete executable files for a specific runtime environment in one step and automatically provides the necessary runtime support.

\flowgraph{\resource{input\\files} \ar[r] & \converter{ecsd} \ar[r] & \resource{executable\\file}}

In contrast to all other tools of the \ecs{}, the driver tool does support the notion of command-line options to allow users to influence how tools are identified and invoked.
The following command-line call prints a list of all supported command-line arguments:

\begin{quote}\begin{verbatim}
ecsd -h
\end{verbatim}\end{quote}

The remainder of this section consistently uses a short notation for options although all of them have also a longer and more descriptive form prefixed by two dashes.
\ifbook For more information about the user interface of this tool, see Chapter~\ref{interface}. \fi

\subsection{Basic Processing}

All of the tools mentioned in Section~\ref{sec:guidebasic} can also be invoked using the \ecs{} driver by putting \texttt{ecsd~-i} in front of the corresponding command-line call.
This particular option prompts the driver to process the input files given as command-line arguments using the specified tool.
Provided that the corresponding tools are available, the command-line calls for pretty printing, semantic checking, and interpreting for example look like the following:

\begin{quote}\begin{verbatim}
ecsd -i obprint simple.mod
ecsd -i obcheck simple.mod
ecsd -i obrun simple.mod
\end{verbatim}\end{quote}

The actual command-line call used by the driver to invoke the respective tool can be shown by adding the \texttt{-v}~flag.
This enables verbose mode which is especially helpful when building programs as shown in the following section.

\subsection{Building Programs}

If the driver is called without command-line options, it builds complete executable files for a specific runtime environment as described in Section~\ref{sec:guidesimple}.
It infers the set of required tools like compilers, assemblers, and linkers from the type of its input files and automatically invokes one tool after the other with appropriate command-line arguments.
By default, it tries to target its own runtime environment:

\begin{quote}\begin{verbatim}
ecsd simple.mod
\end{verbatim}\end{quote}

In order to explicitly target a runtime environment like Windows, OS~X, or Linux-based operating systems for example, use the \texttt{-t}~option as follows.
A list of all available target environments is accessible using the \texttt{-h}~flag:

\begin{quote}\begin{verbatim}
ecsd -t win64 simple.mod
ecsd -t osx64 simple.mod
ecsd -t amd64linux simple.mod
\end{verbatim}\end{quote}

Using the driver to build programs still generates intermediate files like object files and assembly code listings as before.
Use the \texttt{-c}~flag to compile and assemble input files without invoking the linker at the end:

\begin{quote}\begin{verbatim}
ecsd -c simple.mod
\end{verbatim}\end{quote}

The driver can also be called using the generated intermediate files.
However, because the driver cannot infer which compiler was used to generate object files or assembly code listings in the first place, it must be explicitly told which additional runtime support to include this time.
In the case of the Oberon programming language, the required runtime support is made available using the \texttt{-O}~flag:

\begin{quote}\begin{verbatim}
ecsd -O simple.obf
ecsd -O simple.lst
\end{verbatim}\end{quote}

The driver is able to process several different input files at once which allows building complex programs as described in Section~\ref{sec:guidecomplex}:

\begin{quote}\begin{verbatim}
ecsd complex.mod assign.asm
\end{verbatim}\end{quote}

Combining input files into a single object file can be achieved using the \texttt{-l}~flag.
As before, the resulting library file requires additional runtime support to be specified explicitly when building the program:

\begin{quote}\begin{verbatim}
ecsd -l complex.mod assign.obf
ecsd -O complex.lib
\end{verbatim}\end{quote}

In order to disassemble source code or object files instead of linking them, the driver can be invoked using the \texttt{-d}~flag:

\begin{quote}\begin{verbatim}
ecsd -d assign.asm
ecsd -d assign.obf
\end{verbatim}\end{quote}

Generally, the type of an input file is inferred from its filename extension.
The \texttt{-s}~option allows users to explicitly specify the source type of unknown input files.
A list of all supported source types is accessible using the \texttt{-h}~flag.

\subsection{Debugging Programs}

The \ecs{} driver also allows processing map files generated by linker tools.
This is useful for identifying sections that contain problematic instructions in erroneous programs as described in Section~\ref{sec:guidedebugging}.
Building a complex program as described in the previous section for example generates a file called \file{complex.map}:

\begin{quote}\begin{verbatim}
ecsd complex.mod assign.asm
\end{verbatim}\end{quote}

This file can be passed to the driver which then invokes a debugging tool that reads an address from the standard input stream in order to search for a linked section that encompasses that address.
If the address is mapped, the tool prints the name of the corresponding section and the relative offset of the address:

\begin{quote}\begin{verbatim}
echo 0x4011fe | ecsd complex.map
mapsearch: note: offset 4 in code section 'assign'
\end{verbatim}\end{quote}

If additionally provided with the object file or runtime support containing the identified section, the driver subsequently disassembles the latter when using the \texttt{-d}~flag.
In this particular example, the input address points to the second instruction of the \texttt{assign} procedure written in assembly code:

\begin{quote}\begin{verbatim}
echo 0x4011fe | ecsd -d complex.map assign.obf
mapsearch: note: offset 4 in code section 'assign'
.code assign
   0  8b5c2408        mov  ebx, dword [rsp + 8]
   4  891c2500000000  mov  dword [0], ebx  ; abs @Complex.variable
  11  c3              ret
  12
\end{verbatim}\end{quote}

For more advanced debugging using external debuggers on runtime environments that support them, the \ecs{} driver automatically converts and includes the symbolic debugging information generated by compilers using the \texttt{-g} flag:

\begin{quote}\begin{verbatim}
ecsd -g simple.mod
ecsd -g complex.mod assign.asm
\end{verbatim}\end{quote}

This generates executable files that incorporate the address mapping of all symbols and instructions necessary for interactive program animation and memory inspection when loaded in a debugger.

\concludechapter
