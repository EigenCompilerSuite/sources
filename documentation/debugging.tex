% Debugging information representation
% Copyright (C) Florian Negele

% This file is part of the Eigen Compiler Suite.

% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.3
% or any later version published by the Free Software Foundation.

% You should have received a copy of the GNU Free Documentation License
% along with the ECS.  If not, see <https://www.gnu.org/licenses/>.

\input{utilities}
\renewcommand{\seedebugging}{}

\startchapter{Debugging Information}{Debugging Information Representation}{debugging}
{This \documentation{} describes the debugging information generated by the compilers of the \ecs{} and its open file format.
Additionally, it describes the functionality and interface of the debugging information converter tools provided by the \ecs{}.}

\epigraph{Every failure is a step to success.}{William Whewell}

\section{Introduction}

Although the \ecs{} does not provide its own debugger tool, its compiler tools do collect and store \emph{debugging information} for external debuggers.
The debugging information generated alongside an object file consists of an abstract representation of all programming language constructs like functions, variables, data types, and statements compiled into the object file.
It is designed to enable debuggers to support \emph{program animation} and \emph{memory inspection}.
For this purpose, the \ecs{} provides converter tools which generate a binary representation of the debugging information and store it in specific debugging data formats using additional object files as shown in Figure~\ref{fig:dbgdataflow}.
The resulting debugging object files can later be optionally linked together with the original object file.
\seeobject

\begin{figure}
\flowgraph{
\resource{source code} \ar[d] & \resource{source code} \ar[d] & \resource{source code} \ar[d] \\
\converter{Compiler \textit{A}} \ar[d] \ar[rd] & \converter{Compiler \textit{B}} \ar[d] & \converter{Compiler \textit{C}} \ar[d] \ar[ld] \\
\resource{object file} & \resource{debugging\\information} \ar[ld] \ar[d] \ar[rd] & \resource{object file} \\
\converter{Converter \textit{X}} \ar[d] & \converter{Converter \textit{Y}} \ar[d] & \converter{Converter \textit{Z}} \ar[d] \\
\resource{debugging\\object file} & \resource{debugging\\object file} & \resource{debugging\\object file} \\
}\caption[Debugging information representation of programs]{Debugging information representation of programs in-between compilers and converters}
\label{fig:dbgdataflow}
\end{figure}

Converting debugging information into separate object files effectively decouples a compiler from the debugger of the target runtime environment and its required debugging data format.
It also ensures that compilers always generate the same output regardless of whether the resulting binary executable is subject to debugging or not.
The following sections describe the semantics of the debugging information representation alongside the syntax of its textual file format.

\section{Debugging Information Structure}

The debugging information generated by the various compiler tools of the \ecs{} always consists of a short description of target hardware architecture.
It also contains a list of \emph{information entries} which are generic representations of programming language constructs like functions, variables, or data types.

\subsection{Information Entries}\label{sec:dbginformationentries}

Each information entry has a unique name and a \emph{source code location} referring to its textual declaration in the source code.
The \ecs{} supports the following kinds of information entries:

\begin{itemize}

\item Code Entry\alignright\syntax{"code"}\nopagebreak

A code entry represents a functional unit of the programming language like a function or procedure and corresponds to the code section in the object file with the same name.
It contains a \emph{type declaration} which describes the memory layout and data representation of the returned result.
It additionally holds of a list of \emph{symbol declarations} which describe the storage objects declared by this information entry.
It also contains a list of \emph{breakpoints} which associate source code locations of statements with the corresponding machine code offsets in the code section.

\item Data Entry\alignright\syntax{"data"}\nopagebreak

A data entry represents a data unit of the programming language like a global variable and corresponds to the data section in the object file with the same name.
It contains a type declaration for the storage object represented by the data section.

\item Type Entry\alignright\syntax{"type"}\nopagebreak

A type entry represents a named type definition of the programming language.
It contains a type declaration and may omit the source code location for predefined types.

\end{itemize}

\subsection{Symbol Declarations}\label{sec:dbgsymboldeclarations}

A symbol declaration refers to a single storage object managed by a code section like a local variable or parameter.
It has a unique name and a source code location referring to its corresponding declaration in the source code.
It also contains a type declaration for the data type of its storage object and a description of its \emph{lifetime} in terms of a range of offsets in the code section wherein the symbol is considered alive.
The \ecs{} supports the following kinds of symbol declarations:

\begin{itemize}

\item Constant Declaration\nopagebreak

A constant declaration refers to a constant or storage object that is not supposed to change its value.
Since a constant declaration must not necessarily refer to an actually existing storage object, it is represented using its constant value.

\item Register Declaration\nopagebreak

A register declaration refers to a storage object which is stored in a register.
The register of the target hardware architecture is represented using its name.

\item Variable Declaration\nopagebreak

A variable declaration refers to a storage object that has an actual memory address.
The address refers either to a data section or to a displaced register that typically names the frame pointer.

\end{itemize}

\subsection{Type Declarations}\label{sec:dbgtypedeclarations}

A type declaration describes the layout and data representation of memory regions occupied by storage objects.
The \ecs{} supports the following kinds of type declarations:

\begin{itemize}

\item Void Type\alignright\syntax{"void"}\nopagebreak

A void type represents an unspecified, ambiguous, or nonexistent type of the programming language.

\item Type Name\alignright\syntax{<Name>}\nopagebreak

A type name refers to the specified type entry, see Section~\ref{sec:dbginformationentries}.

\item Signed Integer Type\alignright\syntax{"signed"}\nopagebreak

A signed integer type represents a storage object with a given size that stores a single signed integer value using two's complement as signed magnitude representation.

\item Unsigned Integer Type\alignright\syntax{"unsigned"}\nopagebreak

An unsigned integer type represents a storage object with a given size that stores a single unsigned integer value.

\item Floating-point Number Type\alignright\syntax{"float"}\nopagebreak

A floating-point number type represents a storage object with a given size that stores a single floating-point number value according to formats defined in the IEEE standard for floating-point arithmetic~\cite{ieee1985}.

\item Enumeration Type\alignright\syntax{"enumeration"}\nopagebreak

An enumeration type represents a storage object that stores a single integer value from a predefined set of named constants called \emph{enumerators}.
It contains the type of the underlying integer type and declarations for each enumerator.

\item Array Type\alignright\syntax{"array"}\nopagebreak

An array type represents a collection of consecutive storage objects with the same type called its elements.
It contains the index of its first element, the number of elements in case the array has a static size, and a declaration for the element type.

\item Record Type\alignright\syntax{"record"}\nopagebreak

A record type describes a user-defined data structure that contains an arbitrary number of storage objects called fields.
It contains an overall size of the data structure and declarations for each field.

\item Pointer Type\alignright\syntax{"pointer"}\nopagebreak

A pointer type represents a dereferencable storage object that stores a potentially invalid address of another storage object.
It contains the type of the referenced storage object.

\item Reference Type\alignright\syntax{"reference"}\nopagebreak

A reference type represents a dereferencable storage object that stores a valid address of another storage object.
It contains the type of the referenced storage object.

\item Function Type\alignright\syntax{"function"}\nopagebreak

A function type represents the type of a functional unit of the programming language.
It contains type declarations for the returned result and each function parameter.

\end{itemize}

\section{Debugging Information Format}

The debugging information generated by compiler tools is stored in plain text files according to the complete syntax specification given in Figure~\ref{fig:dbgfileformat}.
A debugging information file consists of a description of its target as well as an arbitrary number of sources and information entries according to the following syntax:

\begin{figure}
\centering\ifbook\small\fi\setlength{\grammarparsep}{0ex}
\begin{minipage}{34em}\begin{grammar}
<Information> = <Target> <Sources> <Entries>$\opt$ \par
<Target> = <Name> <Endianness> <Pointer> \par
<Name> = double-quoted-string \par
<Endianness> = "little" $\mid$ "big" \par
<Pointer> = <Size> \par
<Size> = decimal-integer \par
<Sources> = <Source> $\mid$ <Sources> <Source> \par
<Source> = double-quoted-string \par
<Entries> = <Entry> $\mid$ <Entries> <Entry> \par
<Entry> = "code" <Name> <Location> <Type> <Size> <Symbols>$\opt$ <Breakpoints>$\opt$ $\mid$ \\ "data" <Name> <Location> <Type> <Size> $\mid$ \\ "type" <Name> <Location>$\opt$ <Type> \par
<Location> = <Index> <Line> <Column> \par
<Index> = decimal-integer \par
<Line> = decimal-integer \par
<Column> = decimal-integer \par
<Type> = "void" $\mid$ <Name> $\mid$ "signed" <Size> $\mid$ "unsigned" <Size> $\mid$ "float" <Size> $\mid$ \\ "array" <Index> <Size> <Type> $\mid$ "record" <Size> <Fields>$\opt$ $\mid$ \\ "pointer" <Type> $\mid$ "reference" <Type> $\mid$ \\ "function" <Size> <Type> <Parameters>$\opt$ $\mid$ \\ "enumeration" <Type> <Enumerators> \par
<Fields> = <Field> $\mid$ <Fields> <Field> \par
<Field> = <Name> <Location> <Type> <Offset> <Bitmask> \par
<Offset> = decimal-integer \par
<Bitmask> = decimal-integer \par
<Parameters> = <Parameter> $\mid$ <Parameters> <Parameter> \par
<Parameter> = <Type> \par
<Enumerators> = <Enumerator> $\mid$ <Enumerators> <Enumerator> \par
<Enumerator> = <Name> <Location> <Value> \par
<Value> = signed-decimal-integer $\mid$ decimal-integer \par
<Symbols> = <Symbol> $\mid$ <Symbols> <Symbol> \par
<Symbol> = <Name> <Location> <Kind> <Type> <Lifetime> \par
<Kind> = <Constant> $\mid$ <Register> $\mid$ <Variable> \par
<Constant> = "signed" signed-decimal-integer $\mid$ \\ "unsigned" decimal-integer $\mid$ \\ "float" decimal-floating-point \par
<Register> = <Name> \par
<Variable> = <Register> <Displacement> \par
<Displacement> = signed-decimal-integer \par
<Lifetime> = <Begin> <End> \par
<Begin> = <Offset> \par
<End> = <Offset> \par
<Breakpoints> = <Breakpoint> $\mid$ <Breakpoints> <Breakpoint> \par
<Breakpoint> = <Offset> <Location> \par
\end{grammar}\end{minipage}
\caption{Syntax of the debugging information file format}
\label{fig:dbgfileformat}
\end{figure}

\begin{quote}\begin{grammar}
<Information> = <Target> <Sources> <Entries>$\opt$ \par
<Sources> = <Source> $\mid$ <Sources> <Source> \par
<Source> = double-quoted-string \par
\end{grammar}\end{quote}

The sequence of sources lists all filenames used during compilation and is referenced by index in source code locations.

\subsection{Target Description}

The description of the target architecture is represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Target> = <Name> <Endianness> <Pointer> \par
<Name> = double-quoted-string \par
<Endianness> = "little" $\mid$ "big" \par
<Pointer> = <Size> \par
<Size> = decimal-integer \par
\end{grammar}\end{quote}

The description specifies the unique name of the target architecture as well as its endianness and pointer size expressed in octets.

\subsection{Information Entries}

Information entries are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Entries> = <Entry> $\mid$ <Entries> <Entry> \par
<Entry> = "code" <Name> <Location> <Type> <Size> <Symbols>$\opt$ <Breakpoints>$\opt$ $\mid$ \\ "data" <Name> <Location> <Type> <Size> $\mid$ \\ "type" <Name> <Location>$\opt$ <Type> \par
<Name> = double-quoted-string \par
<Size> = decimal-integer \par
\end{grammar}\end{quote}

The valid identifiers for the kind of the information entry correspond to the information entries described in Section~\ref{sec:dbginformationentries}.
The size of an entry is expressed in octets.

\subsection{Source Code Locations}

Source code locations associated with information entries, symbol declarations, field declarations, enumerator declarations, and breakpoints are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Location> = <Index> <Line> <Column> \par
<Index> = decimal-integer \par
<Line> = decimal-integer \par
<Column> = decimal-integer \par
\end{grammar}\end{quote}

The zero-based index refers to one of the sources listed at the beginning of the debugging information in order of occurrence.
Line and column numbering starts with one where all white-space characters are counted as single characters.

\subsection{Symbol Declarations}

Symbol declarations are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Symbols> = <Symbol> $\mid$ <Symbols> <Symbol> \par
<Symbol> = <Name> <Location> <Kind> <Type> <Lifetime> \par
<Name> = double-quoted-string \par
<Kind> = <Constant> $\mid$ <Register> $\mid$ <Variable> \par
<Constant> = "signed" signed-decimal-integer $\mid$ \\ "unsigned" decimal-integer $\mid$ \\ "float" decimal-floating-point \par
<Register> = <Name> \par
<Variable> = <Register> <Displacement> \par
<Displacement> = signed-decimal-integer \par
<Lifetime> = <Begin> <End> \par
<Begin> = <Offset> \par
<End> = <Offset> \par
<Offset> = decimal-integer \par
\end{grammar}\end{quote}

The valid kinds of symbols correspond to the symbol declarations described in Section~\ref{sec:dbgsymboldeclarations}.
The offsets of symbol lifetimes refer to machine code instructions relative to the beginning of the code section corresponding to the enclosing code entry and are expressed in octets.
A symbol declaration with an empty name conventionally denotes the result of the code section rather than a local variable or parameter.
A variable with a displacement of zero names a data section rather than a register.

\subsection{Type Declarations}

Type declarations are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Type> = "void" $\mid$ <Name> $\mid$ "signed" <Size> $\mid$ "unsigned" <Size> $\mid$ "float" <Size> $\mid$ \\ "array" <Index> <Size> <Type> $\mid$ "record" <Size> <Fields>$\opt$ $\mid$ \\ "pointer" <Type> $\mid$ "reference" <Type> $\mid$ \\ "function" <Size> <Type> <Parameters>$\opt$ $\mid$ \\ "enumeration" <Type> <Enumerators> \par
<Name> = double-quoted-string \par
<Size> = decimal-integer \par
<Index> = decimal-integer \par
<Parameters> = <Parameter> $\mid$ <Parameters> <Parameter> \par
<Parameter> = <Type> \par
\end{grammar}\end{quote}

The valid kinds of types correspond to the type declarations described in Section~\ref{sec:dbgtypedeclarations}.
The size of a type is expressed in octets except for array types where it denotes the number of array elements, and for function types where it denotes the number of parameters.

\subsection{Field Declarations}

Field declarations are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Fields> = <Field> $\mid$ <Fields> <Field> \par
<Field> = <Name> <Location> <Type> <Offset> <Bitmask> \par
<Name> = double-quoted-string \par
<Offset> = decimal-integer \par
<Bitmask> = decimal-integer \par
\end{grammar}\end{quote}

The offset specifies the address of the storage object relative to the beginning of the enclosing data structure and is expressed in octets.
The binary value of the non-zero bitmask specifies the number and consecutive sequence of bits occupied by the storage object in case a bit field is declared.
A field declaration with an empty name conventionally denotes inheritance rather than composition.

\subsection{Enumerator Declarations}

Enumerator declarations are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Enumerators> = <Enumerator> $\mid$ <Enumerators> <Enumerator> \par
<Enumerator> = <Name> <Location> <Value> \par
<Name> = double-quoted-string \par
<Value> = signed-decimal-integer $\mid$ decimal-integer \par
\end{grammar}\end{quote}

The constant value of an enumerator is an optionally signed integer that belongs to the underlying integer type of the corresponding enumeration.

\subsection{Breakpoints}

Breakpoints are represented in the debugging information file as text according to the following syntax:

\begin{quote}\begin{grammar}
<Breakpoints> = <Breakpoint> $\mid$ <Breakpoints> <Breakpoint> \par
<Breakpoint> = <Offset> <Location> \par
<Offset> = decimal-integer \par
\end{grammar}\end{quote}

The offset refers to a machine code instruction relative to the beginning of the code section corresponding to the enclosing code entry and is expressed in octets.

\section{Converter Tools}

Converters process debugging information files that were previously generated by the various compiler tools of the \ecs{}.
They store debugging information in object files that represent the same information in a binary debugging data format suitable for the debugger of the target runtime environment.
\interface

\dbgdwarf

\concludechapter
